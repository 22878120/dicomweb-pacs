{"version":3,"sources":["webpack:///D:/dev/web/Viewers/extensions/dicom-sr/src/utils/getToolStateToCornerstoneMeasurementSchema.js","webpack:///D:/dev/web/Viewers/extensions/dicom-sr/src/OHIFCornerstoneSRViewport.js"],"names":["getToolStateToCornerstoneMeasurementSchema","toolType","MeasurementService","imageId","_getValueTypeFromToolType","VALUE_TYPES","POLYLINE","ELLIPSE","POINT","Length","EllipticalRoi","Bidirectional","BIDIRECTIONAL","ArrowAnnotate","measurementData","tool","toolName","instance","cornerstone","metaData","get","SOPInstanceUID","FrameOfReferenceUID","SeriesInstanceUID","StudyInstanceUID","handles","points","Object","keys","map","handle","includes","point","x","y","push","id","referenceSeriesUID","referenceStudyUID","label","text","description","unit","length","type","longAxis","start","end","shortAxis","perpendicularStart","perpendicularEnd","shortestDiameter","longestDiameter","halfXLength","Math","abs","halfYLength","center","area","cachedStats","formatDate","utils","scrollToIndex","cornerstoneTools","importInternal","globalImageIdSpecificToolStateManager","OHIF","StackManager","guid","OHIFCornerstoneSRViewport","sendTrackedMeasurementsEvent","children","dataSource","displaySet","viewportIndex","servicesManager","extensionManager","services","DisplaySetService","useViewportGrid","viewportGrid","viewportGridService","useState","measurementSelected","setMeasurementSelected","measurementCount","setMeasurementCount","viewportData","setViewportData","activeDisplaySetData","setActiveDisplaySetData","element","setElement","isHydrated","setIsHydrated","viewports","activeViewportIndex","registeredExtensionIds","contextModule","getModuleEntry","useContext","context","useEffect","isLoaded","load","setTrackingUniqueIdentifiersForElement","useCallback","targetElement","measurements","getModule","setters","trackingUniqueIdentifiersForElement","measurement","TrackingUniqueIdentifier","numMeasurements","displaySetInstanceUID","updateViewport","newMeasurementSelected","sopClassUids","console","warn","_getViewportAndActiveDisplaySetData","then","stack","currentImageIdIndex","updateImage","firstViewportIndexWithMatchingDisplaySetUid","findIndex","vp","childrenWithProps","imageIds","child","index","React","cloneElement","key","Modality","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","ManufacturerModelName","StudyDate","SeriesDescription","PixelSpacing","SeriesNumber","_viewportLabels","onDoubleClick","evt","stopPropagation","preventDefault","onSeriesChange","direction","onHydrationClick","mappings","getSourceMappings","Error","DicomMetadataStore","getInstance","MeasurementReport","adapters","Cornerstone","sopInstanceUIDToImageId","forEach","ReferencedSOPInstanceUID","storedMeasurementByToolType","generateToolState","mappingDefinitions","m","definition","hydratableMeasurementsInSR","targetStudyInstanceUID","data","sopInstanceUid","SeriesInstanceUIDs","i","toolState","saveToolState","undefined","imageIdToolState","_addToolDataToCornerstoneTools","toMeasurementSchema","source","getSource","addRawMeasurement","setDisplaysetForViewport","showNavArrows","studyData","isTracked","isLocked","studyDate","currentSeries","seriesDescription","modality","patientInformation","patientName","formatPN","Alphabetic","patientSex","patientAge","MRN","thickness","toFixed","spacing","scanner","className","onElementEnabled","detail","globalTools","store","state","globalToolName","setToolDisabledForElement","setToolEnabledForElement","TOOL_NAMES","DICOM_SR_DISPLAY_TOOL","setToolActiveForElement","pointers","mouseButtonMask","imageIdIndex","isActive","isStackPrefetchEnabled","isPlaying","frameRate","isOverlayVisible","resizeRefreshRateMs","_getCornerstoneStack","getDisplaySetByUID","storedStack","findOrCreateStack","assign","activeTrackingUniqueIdentifierForElement","referencedDisplaySet","image0","images","propTypes","PropTypes","object","isRequired","number","node","customProps","defaultProps"],"mappings":"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","file":"3.bundle.497c8c84878a88907a7e.js","sourcesContent":["export default function getToolStateToCornerstoneMeasurementSchema(\r\n  toolType,\r\n  MeasurementService,\r\n  imageId\r\n) {\r\n  const _getValueTypeFromToolType = toolType => {\r\n    const {\r\n      POLYLINE,\r\n      ELLIPSE,\r\n      POINT,\r\n      BIDIRECTIONAL,\r\n    } = MeasurementService.VALUE_TYPES;\r\n\r\n    // TODO -> I get why this was attemped, but its not nearly flexible enough.\r\n    // A single measurement may have an ellipse + a bidirectional measurement, for instances.\r\n    // You can't define a bidirectional tool as a single type..\r\n    // OHIF-230\r\n    const TOOL_TYPE_TO_VALUE_TYPE = {\r\n      Length: POLYLINE,\r\n      EllipticalRoi: ELLIPSE,\r\n      Bidirectional: BIDIRECTIONAL,\r\n      ArrowAnnotate: POINT,\r\n    };\r\n\r\n    return TOOL_TYPE_TO_VALUE_TYPE[toolType];\r\n  };\r\n\r\n  switch (toolType) {\r\n    case 'Length':\r\n      return measurementData =>\r\n        Length(measurementData, imageId, _getValueTypeFromToolType);\r\n    case 'Bidirectional':\r\n      return measurementData =>\r\n        Bidirectional(measurementData, imageId, _getValueTypeFromToolType);\r\n    case 'EllipticalRoi':\r\n      return measurementData =>\r\n        EllipticalRoi(measurementData, imageId, _getValueTypeFromToolType);\r\n    case 'ArrowAnnotate':\r\n      return measurementData =>\r\n        ArrowAnnotate(measurementData, imageId, _getValueTypeFromToolType);\r\n  }\r\n}\r\n\r\nfunction Length(measurementData, imageId, _getValueTypeFromToolType) {\r\n  const tool = measurementData.toolType || measurementData.toolName;\r\n  const instance = cornerstone.metaData.get('instance', imageId);\r\n  const {\r\n    SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n  } = instance;\r\n\r\n  const { handles } = measurementData;\r\n\r\n  const points = [];\r\n  Object.keys(handles).map(handle => {\r\n    if (['start', 'end'].includes(handle)) {\r\n      let point = {};\r\n      if (handles[handle].x) point.x = handles[handle].x;\r\n      if (handles[handle].y) point.y = handles[handle].y;\r\n      points.push(point);\r\n    }\r\n  });\r\n\r\n  return {\r\n    id: measurementData.id,\r\n    SOPInstanceUID: SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    referenceSeriesUID: SeriesInstanceUID,\r\n    referenceStudyUID: StudyInstanceUID,\r\n    label: measurementData.text,\r\n    description: measurementData.description,\r\n    unit: measurementData.unit,\r\n    length: measurementData.length,\r\n    type: _getValueTypeFromToolType(tool),\r\n    points,\r\n  };\r\n}\r\n\r\nfunction Bidirectional(measurementData, imageId, _getValueTypeFromToolType) {\r\n  const tool = measurementData.toolType || measurementData.toolName;\r\n  const instance = cornerstone.metaData.get('instance', imageId);\r\n  const {\r\n    SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n  } = instance;\r\n\r\n  const { handles } = measurementData;\r\n\r\n  const longAxis = [handles.start, handles.end];\r\n  const shortAxis = [handles.perpendicularStart, handles.perpendicularEnd];\r\n\r\n  return {\r\n    id: measurementData.id,\r\n    SOPInstanceUID: SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    referenceSeriesUID: SeriesInstanceUID,\r\n    referenceStudyUID: StudyInstanceUID,\r\n    label: measurementData.text,\r\n    description: measurementData.description,\r\n    unit: measurementData.unit,\r\n    shortestDiameter: measurementData.shortestDiameter,\r\n    longestDiameter: measurementData.longestDiameter,\r\n    type: _getValueTypeFromToolType(tool),\r\n    points: { longAxis, shortAxis },\r\n  };\r\n}\r\n\r\nfunction EllipticalRoi(measurementData, imageId, _getValueTypeFromToolType) {\r\n  const tool = measurementData.toolType || measurementData.toolName;\r\n  const instance = cornerstone.metaData.get('instance', imageId);\r\n  const {\r\n    SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n  } = instance;\r\n\r\n  const { start, end } = measurementData.handles;\r\n\r\n  const halfXLength = Math.abs(start.x - end.x) / 2;\r\n  const halfYLength = Math.abs(start.y - end.y) / 2;\r\n\r\n  const points = [];\r\n  const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };\r\n\r\n  // To store similar to SR.\r\n  if (halfXLength > halfYLength) {\r\n    // X-axis major\r\n    // Major axis\r\n    points.push({ x: center.x - halfXLength, y: center.y });\r\n    points.push({ x: center.x + halfXLength, y: center.y });\r\n    // Minor axis\r\n    points.push({ x: center.x, y: center.y - halfYLength });\r\n    points.push({ x: center.x, y: center.y + halfYLength });\r\n  } else {\r\n    // Y-axis major\r\n    // Major axis\r\n    points.push({ x: center.x, y: center.y - halfYLength });\r\n    points.push({ x: center.x, y: center.y + halfYLength });\r\n    // Minor axis\r\n    points.push({ x: center.x - halfXLength, y: center.y });\r\n    points.push({ x: center.x + halfXLength, y: center.y });\r\n  }\r\n\r\n  return {\r\n    id: measurementData.id,\r\n    SOPInstanceUID: SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    referenceSeriesUID: SeriesInstanceUID,\r\n    referenceStudyUID: StudyInstanceUID,\r\n    label: measurementData.text,\r\n    description: measurementData.description,\r\n    unit: measurementData.unit,\r\n    area:\r\n      measurementData.cachedStats &&\r\n      measurementData.cachedStats\r\n        .area /* TODO: Add concept names instead (descriptor) */,\r\n    type: _getValueTypeFromToolType(tool),\r\n    points,\r\n  };\r\n}\r\n\r\nfunction ArrowAnnotate(measurementData, imageId, _getValueTypeFromToolType) {\r\n  const tool = measurementData.toolType || measurementData.toolName;\r\n  const instance = cornerstone.metaData.get('instance', imageId);\r\n  const {\r\n    SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n  } = instance;\r\n\r\n  const { handles } = measurementData;\r\n\r\n  const points = [];\r\n  Object.keys(handles).map(handle => {\r\n    if (['start', 'end'].includes(handle)) {\r\n      let point = {};\r\n      if (handles[handle].x) point.x = handles[handle].x;\r\n      if (handles[handle].y) point.y = handles[handle].y;\r\n      points.push(point);\r\n    }\r\n  });\r\n\r\n  return {\r\n    id: measurementData.id,\r\n    SOPInstanceUID: SOPInstanceUID,\r\n    FrameOfReferenceUID,\r\n    referenceSeriesUID: SeriesInstanceUID,\r\n    referenceStudyUID: StudyInstanceUID,\r\n    label: measurementData.text,\r\n    description: measurementData.description,\r\n    unit: measurementData.unit,\r\n    text: measurementData.text,\r\n    type: _getValueTypeFromToolType(tool),\r\n    points,\r\n  };\r\n}\r\n","import React, { useCallback, useContext, useEffect, useState } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport cornerstoneTools from 'cornerstone-tools';\r\nimport cornerstone from 'cornerstone-core';\r\nimport CornerstoneViewport from 'react-cornerstone-viewport';\r\nimport OHIF, { DicomMetadataStore, utils } from '@ohif/core';\r\nimport { ViewportActionBar, useViewportGrid } from '@ohif/ui';\r\nimport TOOL_NAMES from './constants/toolNames';\r\nimport { adapters } from 'dcmjs';\r\nimport getToolStateToCornerstoneMeasurementSchema from './utils/getToolStateToCornerstoneMeasurementSchema';\r\nimport id from './id';\r\n\r\nconst { formatDate } = utils;\r\nconst scrollToIndex = cornerstoneTools.importInternal('util/scrollToIndex');\r\nconst globalImageIdSpecificToolStateManager =\r\n  cornerstoneTools.globalImageIdSpecificToolStateManager;\r\n\r\nconst { StackManager, guid } = OHIF.utils;\r\n\r\nconst MEASUREMENT_TRACKING_EXTENSION_ID = 'org.ohif.measurement-tracking';\r\n\r\nfunction OHIFCornerstoneSRViewport({\r\n  children,\r\n  dataSource,\r\n  displaySet,\r\n  viewportIndex,\r\n  servicesManager,\r\n  extensionManager,\r\n}) {\r\n  const { DisplaySetService, MeasurementService } = servicesManager.services;\r\n  const [viewportGrid, viewportGridService] = useViewportGrid();\r\n  const [measurementSelected, setMeasurementSelected] = useState(0);\r\n  const [measurementCount, setMeasurementCount] = useState(1);\r\n  const [viewportData, setViewportData] = useState(null);\r\n  const [activeDisplaySetData, setActiveDisplaySetData] = useState({});\r\n  const [element, setElement] = useState(null);\r\n  const [isHydrated, setIsHydrated] = useState(displaySet.isHydrated);\r\n  const { viewports, activeViewportIndex } = viewportGrid;\r\n\r\n  // Optional hook into tracking extension, if present.\r\n  let trackedMeasurements;\r\n  let sendTrackedMeasurementsEvent;\r\n\r\n  if (\r\n    extensionManager.registeredExtensionIds.includes(\r\n      MEASUREMENT_TRACKING_EXTENSION_ID\r\n    )\r\n  ) {\r\n    const contextModule = extensionManager.getModuleEntry(\r\n      'org.ohif.measurement-tracking.contextModule.TrackedMeasurementsContext'\r\n    );\r\n\r\n    const useTrackedMeasurements = () => useContext(contextModule.context);\r\n\r\n    [\r\n      trackedMeasurements,\r\n      sendTrackedMeasurementsEvent,\r\n    ] = useTrackedMeasurements();\r\n  }\r\n\r\n  const onElementEnabled = evt => {\r\n    const eventData = evt.detail;\r\n    const targetElement = eventData.element;\r\n\r\n    // TODO -> This will only be temporary until we set a tool on, and isn't very customizable.\r\n    // Need to discuss how to deal with tools in general in the redesign, since we\r\n    // Previously just had Tool mode state global across the entire viewer.\r\n    const globalTools = cornerstoneTools.store.state.globalTools;\r\n    const globalToolNames = Object.keys(globalTools);\r\n\r\n    globalToolNames.forEach(globalToolName => {\r\n      cornerstoneTools.setToolDisabledForElement(targetElement, globalToolName);\r\n    });\r\n\r\n    cornerstoneTools.setToolEnabledForElement(\r\n      targetElement,\r\n      TOOL_NAMES.DICOM_SR_DISPLAY_TOOL\r\n    );\r\n\r\n    cornerstoneTools.setToolActiveForElement(targetElement, 'PanMultiTouch', {\r\n      pointers: 2,\r\n    });\r\n    cornerstoneTools.setToolActiveForElement(\r\n      targetElement,\r\n      'ZoomTouchPinch',\r\n      {}\r\n    );\r\n\r\n    cornerstoneTools.setToolActiveForElement(targetElement, 'Wwwc', {\r\n      mouseButtonMask: 1,\r\n    });\r\n    cornerstoneTools.setToolActiveForElement(targetElement, 'Pan', {\r\n      mouseButtonMask: 4,\r\n    });\r\n    cornerstoneTools.setToolActiveForElement(targetElement, 'Zoom', {\r\n      mouseButtonMask: 2,\r\n    });\r\n    cornerstoneTools.setToolActiveForElement(\r\n      targetElement,\r\n      'StackScrollMouseWheel',\r\n      {}\r\n    );\r\n\r\n    setTrackingUniqueIdentifiersForElement(targetElement);\r\n\r\n    setElement(targetElement);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!displaySet.isLoaded) {\r\n      displaySet.load();\r\n    }\r\n    setIsHydrated(displaySet.isHydrated);\r\n  }, [displaySet]);\r\n\r\n  const setTrackingUniqueIdentifiersForElement = useCallback(targetElement => {\r\n    const { measurements } = displaySet;\r\n\r\n    const srModule = cornerstoneTools.getModule(id);\r\n\r\n    srModule.setters.trackingUniqueIdentifiersForElement(\r\n      targetElement,\r\n      measurements.map(measurement => measurement.TrackingUniqueIdentifier),\r\n      measurementSelected\r\n    );\r\n  });\r\n\r\n  useEffect(() => {\r\n    const numMeasurements = displaySet.measurements.length;\r\n\r\n    setMeasurementCount(numMeasurements);\r\n  }, [\r\n    dataSource,\r\n    displaySet,\r\n    displaySet.StudyInstanceUID,\r\n    displaySet.displaySetInstanceUID,\r\n  ]);\r\n\r\n  const updateViewport = newMeasurementSelected => {\r\n    const {\r\n      StudyInstanceUID,\r\n      displaySetInstanceUID,\r\n      sopClassUids,\r\n    } = displaySet;\r\n\r\n    if (!StudyInstanceUID || !displaySetInstanceUID) {\r\n      return;\r\n    }\r\n\r\n    if (sopClassUids && sopClassUids.length > 1) {\r\n      console.warn(\r\n        'More than one SOPClassUID in the same series is not yet supported.'\r\n      );\r\n    }\r\n\r\n    _getViewportAndActiveDisplaySetData(\r\n      dataSource,\r\n      displaySet,\r\n      newMeasurementSelected,\r\n      DisplaySetService,\r\n      element\r\n    ).then(({ viewportData, activeDisplaySetData }) => {\r\n      setViewportData({ ...viewportData });\r\n      setActiveDisplaySetData({ ...activeDisplaySetData });\r\n      setMeasurementSelected(newMeasurementSelected);\r\n\r\n      if (element !== null) {\r\n        scrollToIndex(element, viewportData.stack.currentImageIdIndex);\r\n        cornerstone.updateImage(element);\r\n      }\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (element !== null) {\r\n      setTrackingUniqueIdentifiersForElement(element);\r\n    }\r\n  }, [\r\n    dataSource,\r\n    displaySet,\r\n    displaySet.StudyInstanceUID,\r\n    displaySet.displaySetInstanceUID,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    updateViewport(measurementSelected);\r\n  }, [\r\n    dataSource,\r\n    displaySet,\r\n    displaySet.StudyInstanceUID,\r\n    displaySet.displaySetInstanceUID,\r\n    element,\r\n  ]);\r\n\r\n  const firstViewportIndexWithMatchingDisplaySetUid = viewports.findIndex(\r\n    vp => vp.displaySetInstanceUID === displaySet.displaySetInstanceUID\r\n  );\r\n\r\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n  let childrenWithProps = null;\r\n\r\n  if (!viewportData) {\r\n    return null;\r\n  }\r\n\r\n  const {\r\n    imageIds,\r\n    currentImageIdIndex,\r\n    // If this comes from the instance, would be a better default\r\n    // `FrameTime` in the instance\r\n    // frameRate = 0,\r\n  } = viewportData.stack;\r\n\r\n  // TODO: Does it make more sense to use Context?\r\n  if (children && children.length) {\r\n    childrenWithProps = children.map((child, index) => {\r\n      return (\r\n        child &&\r\n        React.cloneElement(child, {\r\n          viewportIndex,\r\n          key: index,\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  const { Modality } = displaySet;\r\n\r\n  const {\r\n    PatientID,\r\n    PatientName,\r\n    PatientSex,\r\n    PatientAge,\r\n    SliceThickness,\r\n    ManufacturerModelName,\r\n    StudyDate,\r\n    SeriesDescription,\r\n    SeriesInstanceUID,\r\n    PixelSpacing,\r\n    SeriesNumber,\r\n    displaySetInstanceUID,\r\n  } = activeDisplaySetData;\r\n\r\n  const onMeasurementChange = direction => {\r\n    let newMeasurementSelected = measurementSelected;\r\n\r\n    if (direction === 'right') {\r\n      newMeasurementSelected++;\r\n\r\n      if (newMeasurementSelected >= measurementCount) {\r\n        newMeasurementSelected = 0;\r\n      }\r\n    } else {\r\n      newMeasurementSelected--;\r\n\r\n      if (newMeasurementSelected < 0) {\r\n        newMeasurementSelected = measurementCount - 1;\r\n      }\r\n    }\r\n\r\n    updateViewport(newMeasurementSelected);\r\n  };\r\n\r\n  function hydrateMeasurementService() {\r\n    // TODO -> We should define a strict versioning somewhere.\r\n    const mappings = MeasurementService.getSourceMappings(\r\n      'CornerstoneTools',\r\n      '4'\r\n    );\r\n\r\n    if (!mappings || !mappings.length) {\r\n      throw new Error(\r\n        `Attempting to hydrate measurements service when no mappings present. This shouldn't be reached.`\r\n      );\r\n    }\r\n\r\n    const instance = DicomMetadataStore.getInstance(\r\n      displaySet.StudyInstanceUID,\r\n      displaySet.SeriesInstanceUID,\r\n      displaySet.SOPInstanceUID\r\n    );\r\n\r\n    const { MeasurementReport } = adapters.Cornerstone;\r\n\r\n    const sopInstanceUIDToImageId = {};\r\n\r\n    displaySet.measurements.forEach(measurement => {\r\n      const { ReferencedSOPInstanceUID, imageId } = measurement;\r\n      if (!sopInstanceUIDToImageId[ReferencedSOPInstanceUID]) {\r\n        sopInstanceUIDToImageId[ReferencedSOPInstanceUID] = imageId;\r\n      }\r\n    });\r\n\r\n    // Use dcmjs to generate toolState.\r\n    const storedMeasurementByToolType = MeasurementReport.generateToolState(\r\n      instance\r\n    );\r\n\r\n    // Filter what is found by DICOM SR to measurements we support.\r\n    const mappingDefinitions = mappings.map(m => m.definition);\r\n    const hydratableMeasurementsInSR = {};\r\n\r\n    Object.keys(storedMeasurementByToolType).forEach(key => {\r\n      if (mappingDefinitions.includes(key)) {\r\n        hydratableMeasurementsInSR[key] = storedMeasurementByToolType[key];\r\n      }\r\n    });\r\n\r\n    if (\r\n      extensionManager.registeredExtensionIds.includes(\r\n        MEASUREMENT_TRACKING_EXTENSION_ID\r\n      )\r\n    ) {\r\n      // Set the series touched as tracked.\r\n      const imageIds = [];\r\n\r\n      Object.keys(hydratableMeasurementsInSR).forEach(toolType => {\r\n        const toolDataForToolType = hydratableMeasurementsInSR[toolType];\r\n\r\n        toolDataForToolType.forEach(data => {\r\n          // Add the measurement to toolState\r\n          const imageId = sopInstanceUIDToImageId[data.sopInstanceUid];\r\n\r\n          if (!imageIds.includes(imageId)) {\r\n            imageIds.push(imageId);\r\n          }\r\n        });\r\n      });\r\n\r\n      let targetStudyInstanceUID;\r\n      const SeriesInstanceUIDs = [];\r\n\r\n      for (let i = 0; i < imageIds.length; i++) {\r\n        const imageId = imageIds[0];\r\n        const {\r\n          SeriesInstanceUID,\r\n          StudyInstanceUID,\r\n        } = cornerstone.metaData.get('instance', imageId);\r\n\r\n        if (!SeriesInstanceUIDs.includes(SeriesInstanceUID)) {\r\n          SeriesInstanceUIDs.push(SeriesInstanceUID);\r\n        }\r\n\r\n        if (!targetStudyInstanceUID) {\r\n          targetStudyInstanceUID = StudyInstanceUID;\r\n        } else if (targetStudyInstanceUID !== StudyInstanceUID) {\r\n          console.warn(\r\n            'NO SUPPORT FOR SRs THAT HAVE MEASUREMENTS FROM MULTIPLE STUDIES.'\r\n          );\r\n        }\r\n      }\r\n\r\n      sendTrackedMeasurementsEvent('SET_TRACKED_SERIES', {\r\n        StudyInstanceUID: targetStudyInstanceUID,\r\n        SeriesInstanceUIDs,\r\n      });\r\n    }\r\n\r\n    Object.keys(hydratableMeasurementsInSR).forEach(toolType => {\r\n      const toolDataForToolType = hydratableMeasurementsInSR[toolType];\r\n\r\n      toolDataForToolType.forEach(data => {\r\n        // Add the measurement to toolState\r\n        const imageId = sopInstanceUIDToImageId[data.sopInstanceUid];\r\n\r\n        data.id = guid();\r\n\r\n        _addToolDataToCornerstoneTools(data, toolType, imageId);\r\n\r\n        // Let the measurement service know we added to toolState\r\n        const toMeasurementSchema = getToolStateToCornerstoneMeasurementSchema(\r\n          toolType,\r\n          MeasurementService,\r\n          imageId\r\n        );\r\n\r\n        const source = MeasurementService.getSource('CornerstoneTools', '4');\r\n\r\n        MeasurementService.addRawMeasurement(\r\n          source,\r\n          toolType,\r\n          data,\r\n          toMeasurementSchema\r\n        );\r\n\r\n        if (!imageIds.includes(imageId)) {\r\n          imageIds.push(imageId);\r\n        }\r\n      });\r\n    });\r\n\r\n    displaySet.isHydrated = true;\r\n\r\n    setIsHydrated(true);\r\n\r\n    viewportGridService.setDisplaysetForViewport({\r\n      viewportIndex: activeViewportIndex,\r\n      displaySetInstanceUID: activeDisplaySetData.displaySetInstanceUID,\r\n    });\r\n  }\r\n\r\n  const label =\r\n    viewports.length > 1\r\n      ? _viewportLabels[firstViewportIndexWithMatchingDisplaySetUid]\r\n      : '';\r\n\r\n  // TODO -> disabled double click for now: onDoubleClick={_onDoubleClick}\r\n\r\n  return (\r\n    <>\r\n      <ViewportActionBar\r\n        onDoubleClick={evt => {\r\n          evt.stopPropagation();\r\n          evt.preventDefault();\r\n        }}\r\n        onSeriesChange={onMeasurementChange}\r\n        onHydrationClick={hydrateMeasurementService}\r\n        showNavArrows={viewportIndex === activeViewportIndex}\r\n        studyData={{\r\n          label,\r\n          isTracked: false,\r\n          isLocked: displaySet.isLocked,\r\n          isHydrated,\r\n          studyDate: formatDate(StudyDate),\r\n          currentSeries: SeriesNumber,\r\n          seriesDescription: SeriesDescription,\r\n          modality: Modality,\r\n          patientInformation: {\r\n            patientName: PatientName\r\n              ? OHIF.utils.formatPN(PatientName.Alphabetic)\r\n              : '',\r\n            patientSex: PatientSex || '',\r\n            patientAge: PatientAge || '',\r\n            MRN: PatientID || '',\r\n            thickness: SliceThickness ? `${SliceThickness.toFixed(2)}mm` : '',\r\n            spacing:\r\n              PixelSpacing && PixelSpacing.length\r\n                ? `${PixelSpacing[0].toFixed(2)}mm x ${PixelSpacing[1].toFixed(\r\n                    2\r\n                  )}mm`\r\n                : '',\r\n            scanner: ManufacturerModelName || '',\r\n          },\r\n        }}\r\n      />\r\n\r\n      <div className=\"relative flex flex-row w-full h-full overflow-hidden\">\r\n        <CornerstoneViewport\r\n          onElementEnabled={onElementEnabled}\r\n          viewportIndex={viewportIndex}\r\n          imageIds={imageIds}\r\n          imageIdIndex={currentImageIdIndex}\r\n          // TODO: ViewportGrid Context?\r\n          isActive={true} // todo\r\n          isStackPrefetchEnabled={true} // todo\r\n          isPlaying={false}\r\n          frameRate={24}\r\n          isOverlayVisible={false}\r\n          // Sync resize throttle w/ sidepanel animation duration to prevent\r\n          // seizure inducing strobe blinking effect\r\n          resizeRefreshRateMs={150}\r\n        />\r\n        {childrenWithProps}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nconst _viewportLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];\r\n\r\nOHIFCornerstoneSRViewport.propTypes = {\r\n  displaySet: PropTypes.object.isRequired,\r\n  viewportIndex: PropTypes.number.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n  customProps: PropTypes.object,\r\n};\r\n\r\nOHIFCornerstoneSRViewport.defaultProps = {\r\n  customProps: {},\r\n};\r\n\r\n/**\r\n * Obtain the CornerstoneTools Stack for the specified display set.\r\n *\r\n * @param {Object} displaySet\r\n * @param {Object} dataSource\r\n * @return {Object} CornerstoneTools Stack\r\n */\r\nfunction _getCornerstoneStack(\r\n  measurement,\r\n  dataSource,\r\n  DisplaySetService,\r\n  element\r\n) {\r\n  const { displaySetInstanceUID, TrackingUniqueIdentifier } = measurement;\r\n\r\n  const displaySet = DisplaySetService.getDisplaySetByUID(\r\n    displaySetInstanceUID\r\n  );\r\n\r\n  // Get stack from Stack Manager\r\n  const storedStack = StackManager.findOrCreateStack(displaySet, dataSource);\r\n\r\n  // Clone the stack here so we don't mutate it\r\n  const stack = Object.assign({}, storedStack);\r\n\r\n  const { imageId } = measurement;\r\n\r\n  stack.currentImageIdIndex = stack.imageIds.findIndex(i => i === imageId);\r\n\r\n  if (element) {\r\n    const srModule = cornerstoneTools.getModule(id);\r\n\r\n    srModule.setters.activeTrackingUniqueIdentifierForElement(\r\n      element,\r\n      TrackingUniqueIdentifier\r\n    );\r\n  }\r\n\r\n  return stack;\r\n}\r\n\r\nasync function _getViewportAndActiveDisplaySetData(\r\n  dataSource,\r\n  displaySet,\r\n  measurementSelected,\r\n  DisplaySetService,\r\n  element\r\n) {\r\n  let viewportData;\r\n\r\n  const { measurements } = displaySet;\r\n  const measurement = measurements[measurementSelected];\r\n\r\n  const stack = _getCornerstoneStack(\r\n    measurement,\r\n    dataSource,\r\n    DisplaySetService,\r\n    element\r\n  );\r\n\r\n  viewportData = {\r\n    StudyInstanceUID: displaySet.StudyInstanceUID,\r\n    displaySetInstanceUID: displaySet.displaySetInstanceUID,\r\n    stack,\r\n  };\r\n\r\n  const { displaySetInstanceUID } = measurement;\r\n\r\n  const referencedDisplaySet = DisplaySetService.getDisplaySetByUID(\r\n    displaySetInstanceUID\r\n  );\r\n\r\n  const image0 = referencedDisplaySet.images[0];\r\n  const activeDisplaySetData = {\r\n    PatientID: image0.PatientID,\r\n    PatientName: image0.PatientName,\r\n    PatientSex: image0.PatientSex,\r\n    PatientAge: image0.PatientAge,\r\n    SliceThickness: image0.SliceThickness,\r\n    StudyDate: image0.StudyDate,\r\n    SeriesDescription: image0.SeriesDescription,\r\n    SeriesInstanceUID: image0.SeriesInstanceUID,\r\n    SeriesNumber: image0.SeriesNumber,\r\n    displaySetInstanceUID,\r\n  };\r\n\r\n  return { viewportData, activeDisplaySetData };\r\n}\r\n\r\nfunction _addToolDataToCornerstoneTools(data, toolType, imageId) {\r\n  const toolState = globalImageIdSpecificToolStateManager.saveToolState();\r\n\r\n  if (toolState[imageId] === undefined) {\r\n    toolState[imageId] = {};\r\n  }\r\n\r\n  const imageIdToolState = toolState[imageId];\r\n\r\n  // If we don't have tool state for this type of tool, add an empty object\r\n  if (imageIdToolState[toolType] === undefined) {\r\n    imageIdToolState[toolType] = {\r\n      data: [],\r\n    };\r\n  }\r\n\r\n  const toolData = imageIdToolState[toolType];\r\n\r\n  toolData.data.push(data);\r\n}\r\n\r\nfunction _onDoubleClick() {\r\n  const cancelActiveManipulatorsForElement = cornerstoneTools.getModule(\r\n    'manipulatorState'\r\n  ).setters.cancelActiveManipulatorsForElement;\r\n  const enabledElements = cornerstoneTools.store.state.enabledElements;\r\n  enabledElements.forEach(element => {\r\n    cancelActiveManipulatorsForElement(element);\r\n  });\r\n}\r\n\r\nexport default OHIFCornerstoneSRViewport;\r\n"],"sourceRoot":""}